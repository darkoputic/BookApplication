{"ast":null,"code":"import _classCallCheck from \"/Users/darkoputic/Projects/Practice/Angular/StoreApplication/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createForOfIteratorHelper from \"/Users/darkoputic/Projects/Practice/Angular/StoreApplication/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _toConsumableArray from \"/Users/darkoputic/Projects/Practice/Angular/StoreApplication/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { createSelector } from '@ngrx/store';\nimport { isDevMode } from '@angular/core';\n\nfunction getInitialEntityState() {\n  return {\n    ids: [],\n    entities: {}\n  };\n}\n\nfunction createInitialStateFactory() {\n  function getInitialState() {\n    var additionalState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return Object.assign(getInitialEntityState(), additionalState);\n  }\n\n  return {\n    getInitialState: getInitialState\n  };\n}\n\nfunction createSelectorsFactory() {\n  function getSelectors(selectState) {\n    var selectIds = function selectIds(state) {\n      return state.ids;\n    };\n\n    var selectEntities = function selectEntities(state) {\n      return state.entities;\n    };\n\n    var selectAll = createSelector(selectIds, selectEntities, function (ids, entities) {\n      return ids.map(function (id) {\n        return entities[id];\n      });\n    });\n    var selectTotal = createSelector(selectIds, function (ids) {\n      return ids.length;\n    });\n\n    if (!selectState) {\n      return {\n        selectIds: selectIds,\n        selectEntities: selectEntities,\n        selectAll: selectAll,\n        selectTotal: selectTotal\n      };\n    }\n\n    return {\n      selectIds: createSelector(selectState, selectIds),\n      selectEntities: createSelector(selectState, selectEntities),\n      selectAll: createSelector(selectState, selectAll),\n      selectTotal: createSelector(selectState, selectTotal)\n    };\n  }\n\n  return {\n    getSelectors: getSelectors\n  };\n}\n\nvar DidMutate = /*#__PURE__*/(function () {\n  (function (DidMutate) {\n    DidMutate[DidMutate[\"EntitiesOnly\"] = 0] = \"EntitiesOnly\";\n    DidMutate[DidMutate[\"Both\"] = 1] = \"Both\";\n    DidMutate[DidMutate[\"None\"] = 2] = \"None\";\n  })(DidMutate || (DidMutate = {}));\n\n  return DidMutate;\n})();\n\nfunction createStateOperator(mutator) {\n  return function operation(arg, state) {\n    var clonedEntityState = {\n      ids: _toConsumableArray(state.ids),\n      entities: Object.assign({}, state.entities)\n    };\n    var didMutate = mutator(arg, clonedEntityState);\n\n    if (didMutate === DidMutate.Both) {\n      return Object.assign({}, state, clonedEntityState);\n    }\n\n    if (didMutate === DidMutate.EntitiesOnly) {\n      return Object.assign(Object.assign({}, state), {\n        entities: clonedEntityState.entities\n      });\n    }\n\n    return state;\n  };\n}\n\nfunction selectIdValue(entity, selectId) {\n  var key = selectId(entity);\n\n  if (isDevMode() && key === undefined) {\n    console.warn('@ngrx/entity: The entity passed to the `selectId` implementation returned undefined.', 'You should probably provide your own `selectId` implementation.', 'The entity that was passed:', entity, 'The `selectId` implementation:', selectId.toString());\n  }\n\n  return key;\n}\n\nfunction createUnsortedStateAdapter(selectId) {\n  function addOneMutably(entity, state) {\n    var key = selectIdValue(entity, selectId);\n\n    if (key in state.entities) {\n      return DidMutate.None;\n    }\n\n    state.ids.push(key);\n    state.entities[key] = entity;\n    return DidMutate.Both;\n  }\n\n  function addManyMutably(entities, state) {\n    var didMutate = false;\n\n    var _iterator = _createForOfIteratorHelper(entities),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var entity = _step.value;\n        didMutate = addOneMutably(entity, state) !== DidMutate.None || didMutate;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return didMutate ? DidMutate.Both : DidMutate.None;\n  }\n\n  function setAllMutably(entities, state) {\n    state.ids = [];\n    state.entities = {};\n    addManyMutably(entities, state);\n    return DidMutate.Both;\n  }\n\n  function setOneMutably(entity, state) {\n    var key = selectIdValue(entity, selectId);\n\n    if (key in state.entities) {\n      state.entities[key] = entity;\n      return DidMutate.EntitiesOnly;\n    }\n\n    state.ids.push(key);\n    state.entities[key] = entity;\n    return DidMutate.Both;\n  }\n\n  function setManyMutably(entities, state) {\n    var didMutateSetOne = entities.map(function (entity) {\n      return setOneMutably(entity, state);\n    });\n\n    switch (true) {\n      case didMutateSetOne.some(function (didMutate) {\n        return didMutate === DidMutate.Both;\n      }):\n        return DidMutate.Both;\n\n      case didMutateSetOne.some(function (didMutate) {\n        return didMutate === DidMutate.EntitiesOnly;\n      }):\n        return DidMutate.EntitiesOnly;\n\n      default:\n        return DidMutate.None;\n    }\n  }\n\n  function removeOneMutably(key, state) {\n    return removeManyMutably([key], state);\n  }\n\n  function removeManyMutably(keysOrPredicate, state) {\n    var keys = keysOrPredicate instanceof Array ? keysOrPredicate : state.ids.filter(function (key) {\n      return keysOrPredicate(state.entities[key]);\n    });\n    var didMutate = keys.filter(function (key) {\n      return key in state.entities;\n    }).map(function (key) {\n      return delete state.entities[key];\n    }).length > 0;\n\n    if (didMutate) {\n      state.ids = state.ids.filter(function (id) {\n        return id in state.entities;\n      });\n    }\n\n    return didMutate ? DidMutate.Both : DidMutate.None;\n  }\n\n  function removeAll(state) {\n    return Object.assign({}, state, {\n      ids: [],\n      entities: {}\n    });\n  }\n\n  function takeNewKey(keys, update, state) {\n    var original = state.entities[update.id];\n    var updated = Object.assign({}, original, update.changes);\n    var newKey = selectIdValue(updated, selectId);\n    var hasNewKey = newKey !== update.id;\n\n    if (hasNewKey) {\n      keys[update.id] = newKey;\n      delete state.entities[update.id];\n    }\n\n    state.entities[newKey] = updated;\n    return hasNewKey;\n  }\n\n  function updateOneMutably(update, state) {\n    return updateManyMutably([update], state);\n  }\n\n  function updateManyMutably(updates, state) {\n    var newKeys = {};\n    updates = updates.filter(function (update) {\n      return update.id in state.entities;\n    });\n    var didMutateEntities = updates.length > 0;\n\n    if (didMutateEntities) {\n      var didMutateIds = updates.filter(function (update) {\n        return takeNewKey(newKeys, update, state);\n      }).length > 0;\n\n      if (didMutateIds) {\n        state.ids = state.ids.map(function (id) {\n          return newKeys[id] || id;\n        });\n        return DidMutate.Both;\n      } else {\n        return DidMutate.EntitiesOnly;\n      }\n    }\n\n    return DidMutate.None;\n  }\n\n  function mapMutably(map, state) {\n    var changes = state.ids.reduce(function (changes, id) {\n      var change = map(state.entities[id]);\n\n      if (change !== state.entities[id]) {\n        changes.push({\n          id: id,\n          changes: change\n        });\n      }\n\n      return changes;\n    }, []);\n    var updates = changes.filter(function (_ref) {\n      var id = _ref.id;\n      return id in state.entities;\n    });\n    return updateManyMutably(updates, state);\n  }\n\n  function mapOneMutably(_ref2, state) {\n    var map = _ref2.map,\n        id = _ref2.id;\n    var entity = state.entities[id];\n\n    if (!entity) {\n      return DidMutate.None;\n    }\n\n    var updatedEntity = map(entity);\n    return updateOneMutably({\n      id: id,\n      changes: updatedEntity\n    }, state);\n  }\n\n  function upsertOneMutably(entity, state) {\n    return upsertManyMutably([entity], state);\n  }\n\n  function upsertManyMutably(entities, state) {\n    var added = [];\n    var updated = [];\n\n    var _iterator2 = _createForOfIteratorHelper(entities),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var entity = _step2.value;\n        var id = selectIdValue(entity, selectId);\n\n        if (id in state.entities) {\n          updated.push({\n            id: id,\n            changes: entity\n          });\n        } else {\n          added.push(entity);\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    var didMutateByUpdated = updateManyMutably(updated, state);\n    var didMutateByAdded = addManyMutably(added, state);\n\n    switch (true) {\n      case didMutateByAdded === DidMutate.None && didMutateByUpdated === DidMutate.None:\n        return DidMutate.None;\n\n      case didMutateByAdded === DidMutate.Both || didMutateByUpdated === DidMutate.Both:\n        return DidMutate.Both;\n\n      default:\n        return DidMutate.EntitiesOnly;\n    }\n  }\n\n  return {\n    removeAll: removeAll,\n    addOne: createStateOperator(addOneMutably),\n    addMany: createStateOperator(addManyMutably),\n    setAll: createStateOperator(setAllMutably),\n    setOne: createStateOperator(setOneMutably),\n    setMany: createStateOperator(setManyMutably),\n    updateOne: createStateOperator(updateOneMutably),\n    updateMany: createStateOperator(updateManyMutably),\n    upsertOne: createStateOperator(upsertOneMutably),\n    upsertMany: createStateOperator(upsertManyMutably),\n    removeOne: createStateOperator(removeOneMutably),\n    removeMany: createStateOperator(removeManyMutably),\n    map: createStateOperator(mapMutably),\n    mapOne: createStateOperator(mapOneMutably)\n  };\n}\n\nfunction createSortedStateAdapter(selectId, sort) {\n  var _createUnsortedStateA = createUnsortedStateAdapter(selectId),\n      removeOne = _createUnsortedStateA.removeOne,\n      removeMany = _createUnsortedStateA.removeMany,\n      removeAll = _createUnsortedStateA.removeAll;\n\n  function addOneMutably(entity, state) {\n    return addManyMutably([entity], state);\n  }\n\n  function addManyMutably(newModels, state) {\n    var models = newModels.filter(function (model) {\n      return !(selectIdValue(model, selectId) in state.entities);\n    });\n\n    if (models.length === 0) {\n      return DidMutate.None;\n    } else {\n      merge(models, state);\n      return DidMutate.Both;\n    }\n  }\n\n  function setAllMutably(models, state) {\n    state.entities = {};\n    state.ids = [];\n    addManyMutably(models, state);\n    return DidMutate.Both;\n  }\n\n  function setOneMutably(entity, state) {\n    var id = selectIdValue(entity, selectId);\n\n    if (id in state.entities) {\n      state.ids = state.ids.filter(function (val) {\n        return val !== id;\n      });\n      merge([entity], state);\n      return DidMutate.Both;\n    } else {\n      return addOneMutably(entity, state);\n    }\n  }\n\n  function setManyMutably(entities, state) {\n    var didMutateSetOne = entities.map(function (entity) {\n      return setOneMutably(entity, state);\n    });\n\n    switch (true) {\n      case didMutateSetOne.some(function (didMutate) {\n        return didMutate === DidMutate.Both;\n      }):\n        return DidMutate.Both;\n\n      case didMutateSetOne.some(function (didMutate) {\n        return didMutate === DidMutate.EntitiesOnly;\n      }):\n        return DidMutate.EntitiesOnly;\n\n      default:\n        return DidMutate.None;\n    }\n  }\n\n  function updateOneMutably(update, state) {\n    return updateManyMutably([update], state);\n  }\n\n  function takeUpdatedModel(models, update, state) {\n    if (!(update.id in state.entities)) {\n      return false;\n    }\n\n    var original = state.entities[update.id];\n    var updated = Object.assign({}, original, update.changes);\n    var newKey = selectIdValue(updated, selectId);\n    delete state.entities[update.id];\n    models.push(updated);\n    return newKey !== update.id;\n  }\n\n  function updateManyMutably(updates, state) {\n    var models = [];\n    var didMutateIds = updates.filter(function (update) {\n      return takeUpdatedModel(models, update, state);\n    }).length > 0;\n\n    if (models.length === 0) {\n      return DidMutate.None;\n    } else {\n      var originalIds = state.ids;\n      var updatedIndexes = [];\n      state.ids = state.ids.filter(function (id, index) {\n        if (id in state.entities) {\n          return true;\n        } else {\n          updatedIndexes.push(index);\n          return false;\n        }\n      });\n      merge(models, state);\n\n      if (!didMutateIds && updatedIndexes.every(function (i) {\n        return state.ids[i] === originalIds[i];\n      })) {\n        return DidMutate.EntitiesOnly;\n      } else {\n        return DidMutate.Both;\n      }\n    }\n  }\n\n  function mapMutably(updatesOrMap, state) {\n    var updates = state.ids.reduce(function (changes, id) {\n      var change = updatesOrMap(state.entities[id]);\n\n      if (change !== state.entities[id]) {\n        changes.push({\n          id: id,\n          changes: change\n        });\n      }\n\n      return changes;\n    }, []);\n    return updateManyMutably(updates, state);\n  }\n\n  function mapOneMutably(_ref3, state) {\n    var map = _ref3.map,\n        id = _ref3.id;\n    var entity = state.entities[id];\n\n    if (!entity) {\n      return DidMutate.None;\n    }\n\n    var updatedEntity = map(entity);\n    return updateOneMutably({\n      id: id,\n      changes: updatedEntity\n    }, state);\n  }\n\n  function upsertOneMutably(entity, state) {\n    return upsertManyMutably([entity], state);\n  }\n\n  function upsertManyMutably(entities, state) {\n    var added = [];\n    var updated = [];\n\n    var _iterator3 = _createForOfIteratorHelper(entities),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var entity = _step3.value;\n        var id = selectIdValue(entity, selectId);\n\n        if (id in state.entities) {\n          updated.push({\n            id: id,\n            changes: entity\n          });\n        } else {\n          added.push(entity);\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    var didMutateByUpdated = updateManyMutably(updated, state);\n    var didMutateByAdded = addManyMutably(added, state);\n\n    switch (true) {\n      case didMutateByAdded === DidMutate.None && didMutateByUpdated === DidMutate.None:\n        return DidMutate.None;\n\n      case didMutateByAdded === DidMutate.Both || didMutateByUpdated === DidMutate.Both:\n        return DidMutate.Both;\n\n      default:\n        return DidMutate.EntitiesOnly;\n    }\n  }\n\n  function merge(models, state) {\n    models.sort(sort);\n    var ids = [];\n    var i = 0;\n    var j = 0;\n\n    while (i < models.length && j < state.ids.length) {\n      var model = models[i];\n      var modelId = selectIdValue(model, selectId);\n      var entityId = state.ids[j];\n      var entity = state.entities[entityId];\n\n      if (sort(model, entity) <= 0) {\n        ids.push(modelId);\n        i++;\n      } else {\n        ids.push(entityId);\n        j++;\n      }\n    }\n\n    if (i < models.length) {\n      state.ids = ids.concat(models.slice(i).map(selectId));\n    } else {\n      state.ids = ids.concat(state.ids.slice(j));\n    }\n\n    models.forEach(function (model, i) {\n      state.entities[selectId(model)] = model;\n    });\n  }\n\n  return {\n    removeOne: removeOne,\n    removeMany: removeMany,\n    removeAll: removeAll,\n    addOne: createStateOperator(addOneMutably),\n    updateOne: createStateOperator(updateOneMutably),\n    upsertOne: createStateOperator(upsertOneMutably),\n    setAll: createStateOperator(setAllMutably),\n    setOne: createStateOperator(setOneMutably),\n    setMany: createStateOperator(setManyMutably),\n    addMany: createStateOperator(addManyMutably),\n    updateMany: createStateOperator(updateManyMutably),\n    upsertMany: createStateOperator(upsertManyMutably),\n    map: createStateOperator(mapMutably),\n    mapOne: createStateOperator(mapOneMutably)\n  };\n}\n\nfunction createEntityAdapter() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var _Object$assign = Object.assign({\n    sortComparer: false,\n    selectId: function selectId(instance) {\n      return instance.id;\n    }\n  }, options),\n      selectId = _Object$assign.selectId,\n      sortComparer = _Object$assign.sortComparer;\n\n  var stateFactory = createInitialStateFactory();\n  var selectorsFactory = createSelectorsFactory();\n  var stateAdapter = sortComparer ? createSortedStateAdapter(selectId, sortComparer) : createUnsortedStateAdapter(selectId);\n  return Object.assign(Object.assign(Object.assign({\n    selectId: selectId,\n    sortComparer: sortComparer\n  }, stateFactory), selectorsFactory), stateAdapter);\n}\n\nvar Dictionary = function Dictionary() {\n  _classCallCheck(this, Dictionary);\n};\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { Dictionary, createEntityAdapter }; //# sourceMappingURL=ngrx-entity.js.map","map":null,"metadata":{},"sourceType":"module"}